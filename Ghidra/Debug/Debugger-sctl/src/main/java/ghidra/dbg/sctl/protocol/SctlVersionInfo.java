/* ###
 * IP: GHIDRA
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package ghidra.dbg.sctl.protocol;

import java.util.*;

import ghidra.dbg.sctl.client.err.SctlIncorrectVersionRequest;
import ghidra.dbg.sctl.client.err.SctlIncorrectVersionResponse;
import ghidra.dbg.sctl.dialect.SctlDialect;
import ghidra.dbg.sctl.protocol.common.request.SctlVersionRequest;
import ghidra.dbg.sctl.protocol.consts.Mkind;
import ghidra.dbg.sctl.protocol.v2012base.x86.linux.Sctl2012LinuxX86Dialect;
import ghidra.dbg.sctl.protocol.v2012base.x86.win.Sctl2012WindowsX86Dialect;
import ghidra.dbg.sctl.protocol.v2012ext.x86.linux.Sctl2012ExtLinuxX86Dialect;
import ghidra.dbg.sctl.protocol.v2012ext.x86.win.Sctl2012ExtWindowsX86Dialect;
import ghidra.dbg.sctl.protocol.v2018base.any.Sctl2018AnyAnyDialect;

/**
 * A static-only class for listing the versions and dialects of SCTL understood by this client
 * 
 * This class cannot be instantiated. It only has static utility methods.
 */
public final class SctlVersionInfo {
	public static final List<SctlDialect> KNOWN_DIALECTS = Arrays.asList(new SctlDialect[] { //
		Sctl2018AnyAnyDialect.INSTANCE, //
		Sctl2012ExtLinuxX86Dialect.INSTANCE, //
		Sctl2012ExtWindowsX86Dialect.INSTANCE, //
		Sctl2012LinuxX86Dialect.INSTANCE, //
		Sctl2012WindowsX86Dialect.INSTANCE, //
	});
	public static final Map<String, SctlDialect> DIALECTS_BY_NAME = makeDialectMap();
	public static final String SCTL_VERSION = "sctl-2012";

	// Static only
	private SctlVersionInfo() {
	}

	/**
	 * Obtain the dialect to which a server agreed
	 * 
	 * This method presumes that the server has replied to a {@code Tversion} request generated by
	 * {@link #makeRequest()}. The request lists all known dialects from which the server must
	 * choose one. This method checks that the response is one of the known dialects and returns an
	 * instance of that dialect.
	 * 
	 * @param reply the reply from the server
	 * @return the agreed-upon dialect
	 * @throws SctlIncorrectVersionResponse if the selected dialect is not known
	 */
	public static SctlDialect agreeDialect(String selected) throws SctlIncorrectVersionResponse {
		// TODO: Spec says multiple dialects may be chosen.... I only take the highest in my list

		String[] parts = selected.split(":");
		if (parts.length != 2) {
			throw new SctlIncorrectVersionResponse(
				"Server responded with malformed version: " + selected);
		}
		if (!SCTL_VERSION.equals(parts[0])) {
			throw new SctlIncorrectVersionResponse(
				"Server ctl version does not match offer: " + parts[0]);
		}
		Set<String> versions = new HashSet<>(Arrays.asList(parts[1].split(",")));
		// Take the "best", and check that it was in the offer
		// Everything in KNOWN_DIALECT ought to have been in the offer
		for (SctlDialect dialect : KNOWN_DIALECTS) {
			if (versions.contains(dialect.getSysVersion())) {
				return dialect;
			}
		}
		throw new SctlIncorrectVersionResponse(
			"Server requested unknown system dialects: " + parts[1]);
	}

	private static Map<String, SctlDialect> makeDialectMap() {
		Map<String, SctlDialect> map = new LinkedHashMap<>();
		for (SctlDialect dialect : KNOWN_DIALECTS) {
			map.put(dialect.getSysVersion(), dialect);
		}
		return Collections.unmodifiableMap(map);
	}

	/**
	 * Generate a {@link Mkind#Tversion} request listing the given dialects
	 * 
	 * @param dialects the supported dialects
	 * @return the request
	 */
	public static SctlVersionRequest makeRequest(Collection<SctlDialect> dialects) {
		StringBuilder sb = new StringBuilder();
		sb.append(SCTL_VERSION);
		sb.append(':');
		boolean first = true;
		for (SctlDialect dialect : dialects) {
			if (!first) {
				sb.append(',');
			}
			else {
				first = false;
			}
			sb.append(dialect.getSysVersion());
		}
		return new SctlVersionRequest(sb.toString());
	}

	/**
	 * Generate a {@link Mkind#Tversion} request listing all dialects known to the client
	 * 
	 * @return the request
	 */
	public static SctlVersionRequest makeRequest() {
		return makeRequest(KNOWN_DIALECTS);
	}

	public static Set<SctlDialect> collectSupported(String offered) {
		String parts[] = offered.split(":");
		if (parts.length != 2) {
			throw new SctlIncorrectVersionRequest("Client offered a malformed version: " + offered);
		}
		if (!SCTL_VERSION.equals(parts[0])) {
			throw new SctlIncorrectVersionRequest(
				"Client ctl version is not supported: " + parts[0]);
		}
		Set<SctlDialect> supported = new LinkedHashSet<>();
		for (String version : parts[1].split(",")) {
			SctlDialect dialect = DIALECTS_BY_NAME.get(version);
			if (dialect != null) {
				supported.add(dialect);
			}
		}
		if (supported.isEmpty()) {
			throw new SctlIncorrectVersionRequest(
				"No versions offered by the client are supported: " + offered);
		}
		return supported;
	}
}
